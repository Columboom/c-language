
## c++基础(基于c)


 > 主要参考资料
 > 1. 《c语言大学教程（第八版）》
 > 2. 黑马程序员:C++教程从0到1入门编程(bilibili)
 > 3. 《数据结构与算法分析（c++版）》

### 类
e?
- 本质：一组相关的数据和函数的集合；
- 定义：
    ```cpp
    class 【类名】{
        private:
            【成员数据/函数...】
        public:
            【成员数据/函数...】
        protected:
            【成员数据/函数...】
    };
    ```
- `private`下的成员只能在该类被访问（第一个`private`可省略）；`public`下的成员可被全局访问；（通常成员数据设为`private`，成员函数设为`public`）
- 类名通常各首字母大写；
- 定义类的对象：`【类名】【对象名】;`
- 通常不创建类的对象就不能访问该类的成员函数；
- 用点运算符调用成员函数：`【对象名】.【成员函数名】(【实参列表】)；`
- 设置和获取对象数据的成员函数通常命名为`set...`和`get...`;
- 在类外定义成员函数需在函数名加前缀`【类名】::`，双冒号为二元作用域运算符；
- 访问对象成员的方法类似结构体；
- 空对象占1字节（用于区分）；
- 只有非静态数据成员属于对象；
- 组合/has-a关系：以对象为成员
- 对象成员初始化：先直接初始化，再将其传到对象初始化列表中；
- 类可嵌套，但其作用域仍各自独立；
##### 构造函数
用于初始化对象
-	声明格式：无需声明返回值类型，函数名与类名相同；
-	形参列表后可以加上初始化列表`【数据成员1】(【初始参数名1】),【数据成员2】(【初始参数名2】）,...`（若数据成员为对象类型则括号内改为其初始参数列表），也可以在函数体中用赋值语句初始化；
-	若无显性声明的构造函数，编译器会默认地提供一个不给任何数据成员赋初值的默认构造函数，若有自定义的构造函数，则不再提供默认构造函数；
-	为构造函数设置默认实参：在每个形参后面用`=`（注意，为防止默认实参不匹配，只能在定义或声明时出现一次默认实参）；
-	构造函数其他合法调用格式：显式调用`【类名】【对象名】=【构造函数】；`隐式调用`【类名】【对象名】=【构造函数的单参数】；`
-	c++创建对象时会自动调用构造函数；
-	c++11数据成员可直接在类体中初始化；
-	c++11允许构造函数调用其他重载的构造函数，称为委托构造函数；
-	以下三种情况需要调用复制构造函数（若无定义系统会提供默认）：
	1.	对象需要通过另外一个对象进行初始化；
	2.	对象以值传递作为某个函数参数；
	3.	对象以值传递作为函数返回值；
-	若要实现深拷贝需要自定义复制构造函数；
-	可用`=`将对象按值赋给，会自动调用默认的复制构造函数；
- 相应地，析构函数：执行释放对象内存后的善后工作（自动生成调用）；函数名为类名前加`~`
##### 文件封装
- 为提高安全性和可重用性，建议将类的定义及其成员声明单独放在一个名为`【类名】.h`的头文件中（调用时需用`#include`包含），将类的成员函数的定义单独放在一个名为`【类名】.cpp`的文件中，但都需与主程序在同一根目录下；
- 防止一个头文件被重复调用，在其代码前后加上文件防护：
	```cpp
    #ifndef 【大写类名】_H
	#define 【大写类名】_H
	...
	#endif
    ```
	或者直接在程序头加上`#pragma once`   
##### UML类图
//
##### 友元（函数/类）
可访问该类内所有成员
- 前缀关键字`friend`，须在类内声明，建议置于最前端且不要任何限定符；
- 不具传递性；
##### this指针
- 本质：指向当前对象的指针常量；
-	编译器隐性调用用于成员函数确定操作哪个对象的成员（成员函数隐性接受一个当前对象的指针，函数中成员均匀隐性前缀`this->`）
-	显式使用目的：
	-	防止命名冲突；
	-	返回对象引用 `return *this;`，以实现级联函数调用：`【对象】.【函数1】.【函数2】. ...;`
	-	在成员函数中加入`if(this==NULL)return;`，提高健壮性；
##### 修饰符/限定符
- const
	- 修饰成员函数（置于函数体前）表在该函数体不能修改任何数据成员（构造函数除外）（能用尽量用）；
	- 修饰对象表其不能调用非`const`函数；
- static
    - 类的`static`数据成员所有对象共享，访问格式：`【类名】::【静态成员名】`；须在类外初始化，格式：`【数据类型】 【类名】::【静态成员名】=【初值】`；若省略`=【初值】`则默认初始化为0。
    - `static`函数：不访问非`static`成员，无需对象存在即可调用；
- 成员函数后缀`const`，修饰的是`this`指针，限定其指向的值也不可修改；
- 若用`mutable`修饰成员变量，即使在`const`函数中也可以修改其值；
##### 类型转换
-	类内单参数构造函数可视为先将实参隐式转换成该类的对象再用此对象初始化原对象，故程序中当构造函数形参类型的数据出现在该类对象应该出现的地方时，会自动发生隐式类型转换，用`explicit`该函数可阻止此类转换；
-	若程序中该类对象可能转换为其他指定类型，需重载转换运算符：`operator 【数据类型】() const;`此后程序中当该类对象出现在指定数据类型应该出现的地方时，会自动调用该重载函数进行隐式类型转换；

### string
标准库头文件`<string>`定义中的一个储存字符串的类（默认初始值为空字符串）；
- string是否以`\0`结尾视情况而定；
- 部分成员函数
	- `size()`返回字符个数；
	- `empty()`确定字符串是否为空并返回布尔值；
	- `substr(x,y)`表读取复制字符串从第x位起的y位字符，y省略则全复制；
	- `getline(【实参】,【变量名】)`表从实参中读取字符直到换行符为止并将其放入变量中并丢弃换行符；（用cin代替实参表输入流）
	- `at()`提供边界检查，若实参值未越界则返回该下标处元素的引用，否则抛出异常；
    - 已重载运算符：逐位比较运算符（`== != > < >= <=`）、赋值运算符`=`、连接字符串运算符`+/+=`......

### 异常处理
- 异常类`exception`（属标准库）；含虚函数`what()`返回异常信息字符串；
- 头文件`<stdexcept>`中含其派生类；常将自定义的异常信息字符串传递给这些类的构造函数中；
- 可自定义异常类；
- `throw`抛出语句（后接任意类型操作数）
- `try`语句块：包含可能抛出异常的代码和如果异常应该跳过的代码；
- `catch`语句块：处理指定类型的或其派生类的异常；形参常声明为异常类型的引用；
- 若异常需要进一步处理，可在`catch`内重新抛出该异常（语句：`throw;`），由外部`try`和`catch`再处理；
- 若在当前函数抛出异常但没有被捕获，则会展开函数调用栈，在外层函数中`try`和`catch`，如果一直无法捕获，则最终调用`terminate()`函数终止程序执行；

### 引用
-	实参的别名（对引用的操作实际都发生在目标变量上）
-	本质为一指针常量；
-	声明定义格式：`【变量的数据类型】 &【引用名】=【变量名】;`
-	不可重新赋值；
-	按引用传参（常用于大型的不可修改的实参）效果类似按指针传参；
-	若函数返回值类型为引用，实质上会返回变量地址，甚至可以作为左值允许该变量被修改。
-	（返回值类型非引用时，会将返回值储存在一临时内存中等待赋值）
-	`const`引用可以直接用值初始化（编译器会自动优化）；
```cpp
//e
#include <iostream>
using namespace std;
int &test() {
	static int a = 2;
	return a;
}
int main() {
	int &r = test();
	cout << r << endl;
	test() = 5;
	cout << r << endl;
//	int &a=10;//非法
	const int &a = 10; //合法，编译器自动优化：int temp=10;const int &a=temp;
	return 0;
}
```
### 函数
- 返回值类型不可省略；
- 内联函数：编译器直接将函数代码植入主函数中避免函数调用的开销（用与小而常用的函数）；
	- 前缀关键字`inline`；
- 允许形参列表不同的同名函数（函数重载），调用时编译器将根据实参列表自动匹配；

### 重载运算符
- 不能重载的运算符：`.`、`.*`、`::`、 `? :`
- 不能改变运算符优先性和结合性、操作数个数，不能创建新运算符；
- 若在类内重载运算符，则该运算符最左操作数需是该类的对象；
- 故一般用友元函数重载运算符，函数名为：`operate【重载运算符】`；

### 动态内存管理
- `new`运算符创建动态内存并返回相应类型的指针，若创建失败则抛出异常；
	- 格式：`new 【数据类型】(【初始值】)`
	- c++11可用初始化列表初始化堆区数组；
- `delete`运算符操作数为指针，释放其指向动态内存；
	- delete数组时需在其指针前加符号`[]`；
- new出错时会抛出`bad_alloc`异常（属`<new>`）；
- 若调用`set_new_handler(【new处理函数的指针】)`函数，则new故障时不会抛出异常，而是交给new处理函数处理；
- new处理函数需自定义，须无实参且返回void类型，功能应包含下列三者其一：
	1. 删除其他动态分配内存再次new；
	2. 调用函数`abort()`或`exit()`（属`<cstdlib>`）终止程序；
	3. 抛出异常；
- 防止中途发生异常导致的内存泄露：
	- 类模板`unique_ptr`（属`<memory>`）的对象保存了一个指向动态分配内存的指针，当其析构函数被调用时自动对指针数据成员 delete；
	- 一次只能有一个`unique_ptr`拥有一个该指针，且其指向的不能为数组；

### 类的继承（is-a关系）
- 分单继承、多继承；
- 派生类吸收基类的数据和行为（构造函数 析构函数 重载赋值运算符 除外的所有成员）并增加新的功能（成员）；
- 友元函数不会被继承；
- 继承方式：`public`、`protected`、`private`；
	- 无论哪种继承，基类的`private`类型成员都不能被派生类直接访问；
	- `public`继承下，其他类型成员保持原有访问属性；派生类的对象也是其基类的对象；
	- `protected`继承下，其他类型成员都变为`protected`类型；基类的`protected`类型成员不能被外界访问但可被其派生类访问；
	- `private`继承下，其他类型成员都变为`private`类型；
	- （通常还是使用`private`而非`protected`）
- 若要调用的基类成员在派生类中被重新定义（重载），应在其前加上基类名和`::`；
- 派生类的构造函数和析构函数会显示或自动地调用基类的构造函数和析构函数；
- 格式：`class 【派生类名】 : 【继承方式】 【基类名】`
- 子类构造函数执行时需先调用父类的构造函数，默认调用父类的无参构造函数，或者显示地调用父类的有参构造函数；

### 模板
类/函数模板：不同数据类型同样操作逻辑
-	声明格式：`template <typename/class 【形参类型标识符1】,typename/class 【形参类型标识符2】,...,【数据类型1】 【常量名1】,【数据类型2】 【常量名2】,...>`
-	随后定义该类模板时用上述标识符指代形参类型；
-	其成员函数也称为函数模板；
-	若在类模板定义外声明成员函数，则需要前缀类模板声明语句和关键字`inline`；
-	调用类模板时需用`<>`列表指定形参类型或常量；
-	调用函数模板时可为空列表`<>`，将自动识别且不再支持隐式类型转换；
-	调用函数模板时编译器将根据实参列表自动生成对应函数来执行；
-	可对特定数据类型进行重载，加上前缀`template<>`即可；
-	类模板`<>`参数列表可以设置默认参数；
-	分文件编写时，为避免类模板的成员函数创建时机产生的编译问题，一般不再包含头文件，而是包含一个hpp文件，将头文件和函数实现写在一起；

### 数据类型
- `bool`类型，含`true`和`false`；

### IO流库
- c++文件扩展名可为`.cpp`/`.cxx`/`.C`；
- c++使用类型安全（敏感）的IO操作
- IO操作形式：流，即字节序列
- 低级（无格式）IO以单字节为传输单位，高速高容量，不方便不可移植；
- 高级（格式化）IO以有意义多字节为传输单位（如常见的数据类型），便捷易懂；
- 调用标准库中的`string`、`cout`、`cin`、`endl`等标识符时，应声明语句`using namespace std;`
- `wchar_t`类型：存放非传统的其他字符（来自Unicode）；
- 重载了`<<`为流插入运算符，重载了`>>`为流读取运算符；

##### `iostream`库
- 所含头文件：
	- `<iostream>`：提供了基本IO流服务
	- `<iomanip>`：提供了流操纵符服务
	- `<fstream>`：文件处理相关服务
- 每个类模板都有一个预定义的支持charIO的特化（如`typedef basic_istream<char, char_traits<char> > istream;`）；
- `ios`类：
	- 成员函数
		- `precision()`：设置浮点数精度；
		- `width()`：设置域宽（无参则返回当前设置值）；
		- `fill()`：设置填充字符；
		- `flags()`：无参时返回当前格式设置（`fmtflags`数据类型以整型输出），有参时应用为指定设置；
		- `operator!()`：`badbit`或`failbit`置位时返回`true`；
		- `operator void*()`：`badbit`或`failbit`置位时返回`false`；
		- `tie()`：使两流保持同步；（已自动调用`cin.tie(&cout)`）；
	- 流操纵符：
		- 设置整数流基数（sticky）：`dec`、`oct`、`hex`、`setbase()`；
		- 设置浮点数精度（sticky）（默认为6）：`setprecision()`；
		- 设置域宽：`setw()`（默认右对齐，若不足默认填充空格，若超过则原样输出）；
		- 强制输出浮点数小数点和尾数零（sticky）：`showpoint`；
		- 设置对齐：`left`、`right`、`internal`；
		- 设置填充字符：`setfill()`（指定其后所有输入流不足位宽时的填充字符）；
		- 科学计数法：`scientific`；
		- 定点计数法：`fixed`；
		- 大小写：`uppercase`、`nouppercase`（对十六进制字符以及浮点数的e）；
		- 指定布尔格式（sticky）：`boolalpha`、`nonboolalpha`（将1和0显示为"`true`"和"`false`"）；
		等等；
	- 位测试：
		- `eofbit`：输入流遇到文件结束符时被置位；
		- `failbit`：流格式错误时被置位；
		- `badbit`：数据丢失错误时被置位；
		- `goodbit`：以上三者均没被置位时被置位；

- `istream`类：
	- 对象
		- `cin`：输入流格式：`cin>>...>>...`（与`scanf`不同的是，`cin`在读取`char`时也会自动忽略空白字符）；
	- 成员函数
		- `get`：输入一个字符，无参时返回该值（遇文件结尾返回EOF），接受一个实参时将字符储存于其中返回调用它的`istream`对象的引用，`(【字符数组】,【最大字符数】,【终止符(默认'\n')】)`空字符会被加到末尾（终止符不读取）；
		- `getline`：与三实参`get`函数类似，不同的是读取再删除终止符；
		- `ignore`
		- `eof`：通过`eofbit`判断EOF返回布尔值；
		- `fail`：通过`failbit`判断流格式错误返回布尔值；
		- `bad`：通过`badbit`判断数据丢失错误返回布尔值；
		- `clear`：将指定测试位置位（默认参数时`goodbit`）；
		- `read`：想字符数组输入指定量的原始无格式字节；
		- `write`：从字符数组输出指定量的原始无格式字节；
		- `gcount`：可用于`write`第二个实参计算输入字符个数；

- `ostream`类：
	- 成员函数
		- `put`：输出字符
		- `write(【字符串地址】,【要输出字符个数】)`：无格式输出
		- `rdstate`：返回流的错误状态；
	- 对象
		- `cout`：输出流格式`cout<<...<<...`（`endl`表换行并清空输出缓冲区）；
		- `cerr`：非缓冲输出（插入其中的各个流会立即输出）
		- `cerr`：缓冲输出（插入其中的各个流被储存在缓冲区直到被刷新或缓冲区满才输出）
	- c++会自动判定数据类型（如打印`char*`时会自动打印成`char`，一个解决方法是先转换为`void*`）

### 多态
-	静态多态：重载等；动态多态：虚函数等；
- 常用于实现层次软件系统；
- 背景：
	- 使用对象名和点运算符调用函数都是静态联编；
	- 使用基类的指针虽然可以指向派生类，但编译时只能调用句柄类型即基类的成员函数（即取决于指针或引用的定义类型而非其指向对象的类型）；
- 虚函数：
	- 使用指针或引用调用时，调用哪个类的成员函数取决于被指向的对象的类型而非句柄类型（动态联编）；
	- 只需在基类的成员函数声明（加上前缀`virtual`），派生类中重写即可（为了清晰可再显式声明）；
- 虚析构函数：
	- 为了防止基类指针使用`delete`运算符释放派生类对象时的未定义；
	- 在基类中显式定义一个`public`的虚析构函数，则派生类的析构函数会自动重写虚化；
- c++11中，后缀`final`可防止成员函数被重写或类被继承；
- 抽象（基）类：
	- 不完整，不能实例化；
	- 定义方法：将类中一个或多个虚函数声明为纯虚函数（函数头后缀`=0`，无具体实现）；

### 内存分区
-	栈区(stack)：由编译器按需分配清除。含函数的返回地址、参数、局部变量、返回值等，从高地址向低地址增长。在一个进程中，位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。
-	堆区(heap)： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。从低地址向高地址增长。
	-	堆：由操作系统所维护，调用`malloc()`和`free()`。
    -   自由存储区：调用`new`和`delete`。事实上缺省的全局运算符`new`和`delete`也许会按照`malloc`和`free`的方式来被实现。
-	全局区：主要储存全局变量、静态变量、字符串常量、`const`修饰的全局变量，程序结束时由OS回收。
-	代码区：（共享的、只读的）存储程序的机器代码。

### 虚继承、虚基类表、虚函数表
//?

### 文件
- 头文件`<fstream>`，含`fstream`类、`ifstream`类、`ofstream`类等；
- 类内函数
	- `open(【文件路径】,【打开方式】)`
	- `close()；`
	- `is_open()；`
- 文件读写
  - 写文件：`【ofstream类对象】<<【数据/变量名】；`
  - 读文件方式：（文件指针自动后移）
  	1. `【ifstream类对象】>>【变量名】`（读到空白字符为止）；
  	2. 调用类函数`getline(【变量名】,【最大读取字节数】)`（读取一行）；
  	3. 调用全局函数`getline(【类对象】,【字符串变量】)`（读取一行）；
  	4. 调用类函数`get()`（读到EOF为止）
- 二进制读写
  - 二进制写文件：调用类函数`write((const char *)【内存地址】,【字节大小】)；`
  - 二进制读文件：调用类函数`read((const char *)【内存地址】,【字节大小】)；`
- 若读写均需要，则创建`fstream`类对象；

### STL标准库
六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器；
####  容器（头文件`<【容器名】>`）
#####  string字符串
##### vector
一种可动态扩容的单端数组类型（类模板）；
-	迭代器支持随机访问；
-	通过复制到新的内存空间实现；
-	可参考：<https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html>
-	`capacity`表示容量大小（并未实际分配内存），`size`表示内存大小；
-	`swap`函数实现两`vector`互换，若想将`capacity`设置为`size`，可利用`vector<int>(v).swap(v); `，达到收缩内存的效果；
-	常用`reserve`指定`capacity`预留空间，以减少多次开辟内存的开销；
##### deque
双端数组类型（类模板）
-	迭代器支持随机访问；
-	内部通过中控器管理一个个内存块；
-	双端插入删除效率高，访问效率低；
-	内存变更通过中控器增删内存块实现；
##### stack栈
##### queue队列
##### list双向循环链表
-	`reverse`反转函数；
-	提供自己的`sort`排序函数；
-	`sort()`升序排序，`sort(【布尔返回值的（仿）函数】)`可实现降序排序、自定义类型比较的排序；
##### set/multiset
-	关联式容器，内部用红黑树的平衡二叉检索树实现，采用中序遍历；
-	所有元素都会在插入时自动被排序（储存自定义数据类型时需`set<【数据类型】,【一个包含布尔返回值的仿函数的类】>`）；
-	`set`不允许有重复的元素，`multiset`允许；
##### pair对组
本质是结构体；
##### map/ multimap
-	关联式容器，底层结构是用二叉树实现；
-	元素是`pair`，第一个元素值为键值`key`，第二个元素值为实值`value`；
-	所有元素都会根据元素的键值自动排序插入；
-	其他类似`set/multiset`：
#### 仿函数（函数对象）
-	一个包含重载函数调用操作符`()`的类，其对象常称为函数对象；
-	函数对象调用行为类似函数调用；
-	返回`bool`类型的仿函数称为谓词，该重载`()`函数接受几个参数称为几元谓词，常作为算法实参实现特殊功能；
-	`<functional>`中的仿函数：`template<class T> T 【函数名】<T>`
	-	算术类：四则运算、取模、取相反数；
	-	关系对比类；
	-	逻辑运算与或非；
#### 算法
-	`<algorithm>`：比较、 交换、查找、遍历操作、复制、修改等（只支持于随机访问迭代器）
	-	比较：
		-	`max`
		-	`min`
	-	遍历：
		-	`for_each(【头迭代器】, 【尾迭代器】, 【函数对象】)`遍历
		-	`transform(【原容器头迭代器】, 【原容器尾迭代器】, 【新容器头迭代器】,【函数对象】)`转移（目标容器需要提前开辟空间）
	-	查找：（用于自定义类型时需重载==运算符）
		-	`find`
		-	`find_if`
		-	`adjacent_find`查找相邻重复元素
		-	`binary_search` 只适用于有序序列
	-	计数：
		-	`count`
		-	`count_if`
	-	排序：
		-	`sort(【头迭代器】, 【尾迭代器】,【函数对象】)`
		-	`random_shuffle` 洗牌：随机调整次序（需另加随机数种子）
		-	`merge` 两个有序容器有序地合并存储到另一容器中（目标容器需要提前开辟空间）
		-	`reverse` 反转
	-	复制/替换：
		-	`copy` （目标容器需要提前开辟空间）
		-	`replace`
		-	`replace_if`
		-	`swap`
	-	集合算法：（只适用于有序序列）
		-	`set_intersection` 交集
		-	`set_union` 并集
		-	`set_difference` 差集
-	`<numeric>`：小规模算法
	-	`accumulate` // 计算容器元素累计总和
	-	`fill` // 向容器指定范围中填充元素

### 良好编程习惯
-	类中有虚函数时都应该显示定义虚析构函数；
-	一般不要在类内初始化静态变量；
-	类模板中的友元（全局）函数最好直接在类内实现；
